{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "CwPTdBXs16raLBXoKT5c7",
      "type": "text",
      "x": 39.986600211400344,
      "y": 10655.967287832533,
      "width": 540.739501953125,
      "height": 1350,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aL",
      "roundness": null,
      "seed": 1356313937,
      "version": 1417,
      "versionNonce": 1153215656,
      "isDeleted": true,
      "boundElements": [],
      "updated": 1768413735418,
      "link": null,
      "locked": false,
      "text": "1. Custom hooks - > Bugün gireceğiz bu konuya\n2. state prev nasıl kullanılır -> Bahsettik\n3. single state vs multiple states\n\nState\n=====\nconst [sayi, setSayi] = useState(42);\n\nsetState(sayi + 1)\n\nState prev\n====\nprev her zaman bir önceki değer üzerinde işlem yapar\nNe zaman kullanmalıyız?\n------\n1. Özellikle bir state diğer state ile bağımlıysa:\nsetUser({ ...user, name: \"Ali\" });\nsetUser({ ...user, surname: \"AYAZ\" });\n2. Timer başlattıysak\n// Örneği kodda var\n\nSingle State vs Multiple state\n=====\n- Tek bir state'e her şeyi koymaktan kaçının\n- Ayrı ayrı state değişkenleri olsun\n- Form ile ilgili kısımları => form kütüphanesi\n- Data ile ilgili kısımlar => React Query lib\n\nfetch API\n=====\n- JS'te veri çekmek için network istemleri için gereklidir.\n- ApiCall çağrıları arka planda bunu yapar\n\nfetch(URL)\n   .then(res => res.json())\n   .then(json => setUsers(json))\n\nReact Query\n=====\n- Data fetching library\n- Cache, performans, rerender düzenlemesi sağlar\n- Kodu okunaklı hale getirir\n\nuseQuery\n====\n- GET istekleri içindir\n- queryKey ile birlikte cache parametresi verilir\n- queryFn ile birlikte fetch methodu geçilir\n\nuseMutation\n====\n- POST, DELETE, PUT vs. istekleri içindir\n- mutation ile birlikte fetch methodu geçilir\n- onSuccess'te hangi cache'i temizleyecekse o key geçilir",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "1. Custom hooks - > Bugün gireceğiz bu konuya\n2. state prev nasıl kullanılır -> Bahsettik\n3. single state vs multiple states\n\nState\n=====\nconst [sayi, setSayi] = useState(42);\n\nsetState(sayi + 1)\n\nState prev\n====\nprev her zaman bir önceki değer üzerinde işlem yapar\nNe zaman kullanmalıyız?\n------\n1. Özellikle bir state diğer state ile bağımlıysa:\nsetUser({ ...user, name: \"Ali\" });\nsetUser({ ...user, surname: \"AYAZ\" });\n2. Timer başlattıysak\n// Örneği kodda var\n\nSingle State vs Multiple state\n=====\n- Tek bir state'e her şeyi koymaktan kaçının\n- Ayrı ayrı state değişkenleri olsun\n- Form ile ilgili kısımları => form kütüphanesi\n- Data ile ilgili kısımlar => React Query lib\n\nfetch API\n=====\n- JS'te veri çekmek için network istemleri için gereklidir.\n- ApiCall çağrıları arka planda bunu yapar\n\nfetch(URL)\n   .then(res => res.json())\n   .then(json => setUsers(json))\n\nReact Query\n=====\n- Data fetching library\n- Cache, performans, rerender düzenlemesi sağlar\n- Kodu okunaklı hale getirir\n\nuseQuery\n====\n- GET istekleri içindir\n- queryKey ile birlikte cache parametresi verilir\n- queryFn ile birlikte fetch methodu geçilir\n\nuseMutation\n====\n- POST, DELETE, PUT vs. istekleri içindir\n- mutation ile birlikte fetch methodu geçilir\n- onSuccess'te hangi cache'i temizleyecekse o key geçilir",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "5Bcwxnom4A80maBhPug1o",
      "type": "text",
      "x": 436.0620102160274,
      "y": 10542.598451094373,
      "width": 625.3194580078125,
      "height": 1500,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 1,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aM",
      "roundness": null,
      "seed": 1760690392,
      "version": 2245,
      "versionNonce": 1352638424,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1768419197219,
      "link": null,
      "locked": false,
      "text": "React Query\n=====\nSorunlar\n-------\n1. fetch apisi tam olarak React'e uygun değil\n======\n- sürekli json dönüşümü yapmak gerekiyor\n- useEffect içinde await fetch(API) şeklinde kullanamıyoruz\n- loading, error state gibi kısımları kendimiz yönetmemiz gerekiyor\n- 404, 5xx HTTP status kodları hataya düşmüyor \n\n1.1. Fetch yerine axios kullansak\n====\n- Axios içinde otomatik json donüşümu ve error handling ve\n- Interceptor de var\n- Ama: Kod çok fazla effect ve state kullanıyor hale geliyor.\n- React'in doğasına pek uygun değiller\n\n- Effect ve state'i bir arada tutan\nCustom bir hook yazmamız gerekiyor\n\nCustom hook'lar nasıl çalışır\n=====\n- Içerisinde effect/state barındırıyorlar\n- Business logic tutuyorlar\n- React'in yaşam döngüsü metotlarını kullanıyorlar\n- UI bağımsız fonksiyonlar gibi düşünebiliriz\n- JSX dönmezler\n- Componentin gövdesinde tanımlanırlar\n- useState'i click gibi fonksiyon içinde tanımlayamazsını\n\nuseCounter() örneği\nAşamalar\n=====\n1. UI içerisindeki return kısmı JSX harici tüm kısımları kestik\n2. return kısmında kullanılacak değişkenler hata vermeye başladı\n3. Componentin gövdesinde bir hook  varmış gibi çalıştırdık\nconst {sayi, handleArttir} = useCounter();\n4. Bu bize hook'un döneceği type'ı ipucu olarak verdi\n5. src/hooks içinde useCounter.ts dosyası oluşturduk\n6. Dönecek tip için UseCounterReturn diye bir type oluşturduk\ntype UseCounterReturn {\n   sayi: number;\n   handleArttir: () => void;\n}\n7. Hook oluşturduk aşağıdaki gibi \nexport const useCounter():UseCounterReturn {}  \n8. return ekledik kodun içine\nexport const useCounter():UseCounterReturn {\n    // Bu satira 1. adımda kestiğimiz kodları yapıştırıcaz\n   return {sayi, handleArttir};\n}  \n9. return üstüne o kodları yapıştırdık\n10. Artık tamamdır\n11. index.tsx'e dönüp import'u düzelttik\n12. Opsiyonel: Gereken diğer metot ve Options alanlarını verdi\n\nReact Query\n=====\n",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "React Query\n=====\nSorunlar\n-------\n1. fetch apisi tam olarak React'e uygun değil\n======\n- sürekli json dönüşümü yapmak gerekiyor\n- useEffect içinde await fetch(API) şeklinde kullanamıyoruz\n- loading, error state gibi kısımları kendimiz yönetmemiz gerekiyor\n- 404, 5xx HTTP status kodları hataya düşmüyor \n\n1.1. Fetch yerine axios kullansak\n====\n- Axios içinde otomatik json donüşümu ve error handling ve\n- Interceptor de var\n- Ama: Kod çok fazla effect ve state kullanıyor hale geliyor.\n- React'in doğasına pek uygun değiller\n\n- Effect ve state'i bir arada tutan\nCustom bir hook yazmamız gerekiyor\n\nCustom hook'lar nasıl çalışır\n=====\n- Içerisinde effect/state barındırıyorlar\n- Business logic tutuyorlar\n- React'in yaşam döngüsü metotlarını kullanıyorlar\n- UI bağımsız fonksiyonlar gibi düşünebiliriz\n- JSX dönmezler\n- Componentin gövdesinde tanımlanırlar\n- useState'i click gibi fonksiyon içinde tanımlayamazsını\n\nuseCounter() örneği\nAşamalar\n=====\n1. UI içerisindeki return kısmı JSX harici tüm kısımları kestik\n2. return kısmında kullanılacak değişkenler hata vermeye başladı\n3. Componentin gövdesinde bir hook  varmış gibi çalıştırdık\nconst {sayi, handleArttir} = useCounter();\n4. Bu bize hook'un döneceği type'ı ipucu olarak verdi\n5. src/hooks içinde useCounter.ts dosyası oluşturduk\n6. Dönecek tip için UseCounterReturn diye bir type oluşturduk\ntype UseCounterReturn {\n   sayi: number;\n   handleArttir: () => void;\n}\n7. Hook oluşturduk aşağıdaki gibi \nexport const useCounter():UseCounterReturn {}  \n8. return ekledik kodun içine\nexport const useCounter():UseCounterReturn {\n    // Bu satira 1. adımda kestiğimiz kodları yapıştırıcaz\n   return {sayi, handleArttir};\n}  \n9. return üstüne o kodları yapıştırdık\n10. Artık tamamdır\n11. index.tsx'e dönüp import'u düzelttik\n12. Opsiyonel: Gereken diğer metot ve Options alanlarını verdi\n\nReact Query\n=====\n",
      "autoResize": true,
      "lineHeight": 1.25
    }
  ],
  "appState": {
    "gridSize": 20,
    "gridStep": 5,
    "gridModeEnabled": false,
    "viewBackgroundColor": "#ffffff",
    "lockedMultiSelections": {}
  },
  "files": {}
}