{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "Y46F0K8Cai2FIc3Xlwiic",
      "type": "text",
      "x": 322.1135411564254,
      "y": 9484.676487200706,
      "width": 966.9522705078125,
      "height": 3640,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "b0t",
      "roundness": null,
      "seed": 1749042811,
      "version": 3628,
      "versionNonce": 491651900,
      "isDeleted": true,
      "boundElements": null,
      "updated": 1767633951382,
      "link": null,
      "locked": false,
      "text": "Components\n=====\n- Tekrar tekrar kullanılabilen bileşenlerdir\n\nNeden ihtiyaç var?\n====\n- Birbirine benzeyen kodlar olduğunda kod karmaşası artar.\n- Bir fonksiyon oluşturuyoruz\n- Her bir JSX dönen fonksiyon aslında bir componenttir.\n- <View> <Text> vs dönüyorsa component diyebiliriz.\n- f(x) = y\n- f(type, title) = <TouchableOpacity/>\n- Button(type, title) = <TouchableOpacity/>\n\nProps nedir?\n====\n- Props componente geçmiş olduğumuz parametrelerdir.\n- Props sayesinde componente yeni özellikler ekleyebiliyoruz.\n- f(x) = y dediğimizde x aslında bir props.\n- Props (Properties) = Özelliklerini belirtiyoruz\n- Button(title, type) = title ve type birer prop\n- Bu prop'ları props objesinden alabiliyoruz\n- Button(props) => props.title props.type\n- Button({type, title}) =>\n\nTypeScript\n====\n- JavaScript'i güvenli yazmayı sağlar\n- Ekip içinde hata oluşmasını azaltır\n- . tuşuna bastığımızda çıkan menüde kolaylıkla görebiliriz.\n\nType oluştururken\n====\ntype Props = {\n  title: string;\n  type?: \"primary\" | \"secondary\"; \n}\n\n- ? şu demek: Istersen bu parametreyi geçmeyebilirsin.\n- parametre geçilmediğinde değer undefined olur.\n- undefined'dan uzak durmaya çalışabiliriz.\n\nZamanla if(type === undefined) kontrolleri kodu karmaşıklaştıracaktır.\n\nStyle değiştirme (overwrite) taktikleri\n1. Style parametresi array alabilir\n=====\n- Aşağıdaki gibi birden fazla stili arka arkaya verebiliyoruz.\n<Text style={[style1, style2, {backgroundColor: \"red\"}]}/>\n- style3' te aynı bir özellik varsa style1'deki o özelliği ezer\n\n2. Spread operator\n====\n- Bir obje içindeki özellikleri açıp başka bir obje oluşturmayı sağlar\nconst textStyle = {color: \"white\", fontSize: 18}\nconst newTextStyle = {...text, fontFamily: \"Roboto\"}\n- Kullanırken\n<Text style={{...style.button, fontFamily: \"Roboto\"}}/>\n\nŞu ana kadar gördüklerimiz\n====\n- View: Container component, Kapsayıcıdır\n- Text: Yazı componenti\n- TouchableOpacity: Button için\n- SafeAreaView: Çentik için\n\nState ile component verisi tutma\n====\n- Component içinde değişken veri tutmak içindir\n- usss snippet'ını kullanabilirsiniz\nconst [sayi, setSayi] = useState(0);\n- ilk iki parametre deger ve set eden değerdir.\n- Sonraki geçtiğimiz 0 ise başlangıç değeridir\n- number, string, boolean, array gibi herhangi bir tip tutabiliyor\n- setSayı çağrıldığında React tarafında bir render tetiklenir ve \nekranın yeniden çizilmesi sağlanır. \n\nRerender meselesi\n====\n- Ekranın yeniden çizilmesine rerender denir. \n\nPerformans ipuçları\n====\n- for döngüsünde arka arkaya set etmemek iyidir.\n- Arka arkaya çağırılan state ifadeleri rerender sorununa ve performans\nsorununa yol açabilir\n- Componentin olabildiğince az state'i olmalı\n- state artarsa yeni bir componente ayırmak lazımdır.\n\nImmutablity (değiştirilmezlik) \n===\n- State her defasında yeni bir obje referansı bekler.\n- Bu nedenle array veya obje set ediyorsak spread operatörü kullanırız\nÖrnek\nsetSayilar([...sayilar])\nsetKullanici({...kullanici})\n\nSpread operatörü objeyi açarak yeni bir obje/array oluşturmayı sağlar\n\n\n\n\n\n",
      "fontSize": 28,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Components\n=====\n- Tekrar tekrar kullanılabilen bileşenlerdir\n\nNeden ihtiyaç var?\n====\n- Birbirine benzeyen kodlar olduğunda kod karmaşası artar.\n- Bir fonksiyon oluşturuyoruz\n- Her bir JSX dönen fonksiyon aslında bir componenttir.\n- <View> <Text> vs dönüyorsa component diyebiliriz.\n- f(x) = y\n- f(type, title) = <TouchableOpacity/>\n- Button(type, title) = <TouchableOpacity/>\n\nProps nedir?\n====\n- Props componente geçmiş olduğumuz parametrelerdir.\n- Props sayesinde componente yeni özellikler ekleyebiliyoruz.\n- f(x) = y dediğimizde x aslında bir props.\n- Props (Properties) = Özelliklerini belirtiyoruz\n- Button(title, type) = title ve type birer prop\n- Bu prop'ları props objesinden alabiliyoruz\n- Button(props) => props.title props.type\n- Button({type, title}) =>\n\nTypeScript\n====\n- JavaScript'i güvenli yazmayı sağlar\n- Ekip içinde hata oluşmasını azaltır\n- . tuşuna bastığımızda çıkan menüde kolaylıkla görebiliriz.\n\nType oluştururken\n====\ntype Props = {\n  title: string;\n  type?: \"primary\" | \"secondary\"; \n}\n\n- ? şu demek: Istersen bu parametreyi geçmeyebilirsin.\n- parametre geçilmediğinde değer undefined olur.\n- undefined'dan uzak durmaya çalışabiliriz.\n\nZamanla if(type === undefined) kontrolleri kodu karmaşıklaştıracaktır.\n\nStyle değiştirme (overwrite) taktikleri\n1. Style parametresi array alabilir\n=====\n- Aşağıdaki gibi birden fazla stili arka arkaya verebiliyoruz.\n<Text style={[style1, style2, {backgroundColor: \"red\"}]}/>\n- style3' te aynı bir özellik varsa style1'deki o özelliği ezer\n\n2. Spread operator\n====\n- Bir obje içindeki özellikleri açıp başka bir obje oluşturmayı sağlar\nconst textStyle = {color: \"white\", fontSize: 18}\nconst newTextStyle = {...text, fontFamily: \"Roboto\"}\n- Kullanırken\n<Text style={{...style.button, fontFamily: \"Roboto\"}}/>\n\nŞu ana kadar gördüklerimiz\n====\n- View: Container component, Kapsayıcıdır\n- Text: Yazı componenti\n- TouchableOpacity: Button için\n- SafeAreaView: Çentik için\n\nState ile component verisi tutma\n====\n- Component içinde değişken veri tutmak içindir\n- usss snippet'ını kullanabilirsiniz\nconst [sayi, setSayi] = useState(0);\n- ilk iki parametre deger ve set eden değerdir.\n- Sonraki geçtiğimiz 0 ise başlangıç değeridir\n- number, string, boolean, array gibi herhangi bir tip tutabiliyor\n- setSayı çağrıldığında React tarafında bir render tetiklenir ve \nekranın yeniden çizilmesi sağlanır. \n\nRerender meselesi\n====\n- Ekranın yeniden çizilmesine rerender denir. \n\nPerformans ipuçları\n====\n- for döngüsünde arka arkaya set etmemek iyidir.\n- Arka arkaya çağırılan state ifadeleri rerender sorununa ve performans\nsorununa yol açabilir\n- Componentin olabildiğince az state'i olmalı\n- state artarsa yeni bir componente ayırmak lazımdır.\n\nImmutablity (değiştirilmezlik) \n===\n- State her defasında yeni bir obje referansı bekler.\n- Bu nedenle array veya obje set ediyorsak spread operatörü kullanırız\nÖrnek\nsetSayilar([...sayilar])\nsetKullanici({...kullanici})\n\nSpread operatörü objeyi açarak yeni bir obje/array oluşturmayı sağlar\n\n\n\n\n\n",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "fKad_WUwXTax70X4EO9oF",
      "type": "text",
      "x": 568.8946887616402,
      "y": 12336.189038843459,
      "width": 689.6680297851562,
      "height": 945,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "b0u",
      "roundness": null,
      "seed": 2007120828,
      "version": 786,
      "versionNonce": 490788740,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1767639867286,
      "link": null,
      "locked": false,
      "text": "TextInput\n====\n- Kullanıcı bilgi almayı sağlar.\n- Klavyeden giriş yapılır\n- Web <input> ile eşdeğerdir.\n- React Native'den import edilir.\n- Stillendirilmesi de style ile yapılabilir\n\nState ataması yaparken\n=====\n- value -> Değer ataması yapılır\n- onChangeText={setText}  -> tuş basma eventi\n\nInput tipleri\n=====\nkeyboardType=\"\" ile birlikte verilir\nemail-address: eposta klavyesi içindir\nnumber-pad: sayı girmek içindir.\nphone-pad: telefon numarası girmek içindir\n\nmultiline: Açıklama alanı içindir\nreturnKeyType: Klavyedeki Enter ikonunu değiştirir.\n\nIcons\n===\n- Varsayılan expo-icons kütüphanesi kullanılır\n- icons.expo.fyi sitesinden ilgili ikon koduna ulaşılır",
      "fontSize": 28,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "TextInput\n====\n- Kullanıcı bilgi almayı sağlar.\n- Klavyeden giriş yapılır\n- Web <input> ile eşdeğerdir.\n- React Native'den import edilir.\n- Stillendirilmesi de style ile yapılabilir\n\nState ataması yaparken\n=====\n- value -> Değer ataması yapılır\n- onChangeText={setText}  -> tuş basma eventi\n\nInput tipleri\n=====\nkeyboardType=\"\" ile birlikte verilir\nemail-address: eposta klavyesi içindir\nnumber-pad: sayı girmek içindir.\nphone-pad: telefon numarası girmek içindir\n\nmultiline: Açıklama alanı içindir\nreturnKeyType: Klavyedeki Enter ikonunu değiştirir.\n\nIcons\n===\n- Varsayılan expo-icons kütüphanesi kullanılır\n- icons.expo.fyi sitesinden ilgili ikon koduna ulaşılır",
      "autoResize": true,
      "lineHeight": 1.25
    }
  ],
  "appState": {
    "gridSize": 20,
    "gridStep": 5,
    "gridModeEnabled": false,
    "viewBackgroundColor": "#ffffff",
    "lockedMultiSelections": {}
  },
  "files": {}
}